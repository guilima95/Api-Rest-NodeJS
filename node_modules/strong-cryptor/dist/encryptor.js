"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var crypto_1 = __importDefault(require("crypto"));
var fs_1 = __importDefault(require("fs"));
var config_1 = require("./config");
var provider_1 = require("./provider");
var utils_1 = require("./utils");
var Encryptor = /** @class */ (function () {
    /**
     * Create new instance of encryptor
     * @param {string} key (or secret) is 256bits (32 charcters) that used to encrypt dan decrypt the data, please store it in the safe places
     * @param {IEncryptionOptions} options (encryption options, see [[IEncryptionOptions]] for more details
     */
    function Encryptor(options) {
        if (options.key.length !== 32) {
            throw new provider_1.InvalidKeyError('Key must be 32 characters');
        }
        this.options = options;
    }
    /**
     * set key for encryption process
     * @param {string} key (or secret) is 256bits (32 charcters) that used to encrypt dan decrypt the data, please store it in the safe places
     */
    Encryptor.prototype.setKey = function (key) {
        if (key.length !== 32) {
            throw new provider_1.InvalidKeyError('Key must be 32 characters');
        }
        this.options.key = key;
    };
    /**
     * set options for encryption process
     * @param {IEncryptionOptions} options (encryption options, see [[IEncryptionOptions]] for more details
     */
    Encryptor.prototype.setOptions = function (options) {
        this.options = __assign({}, options, { key: options.key ? options.key : this.options.key });
    };
    /**
     * encrypt the given text with aes-256-cbc encryption algorithm
     * @param {string | Buffer} data string or Buffer that will be encrypted
     * @param {string} key (or secret) is 256bits (32 charcters) that used to encrypt dan decrypt the data, please store it in the safe places
     * @param {IEncryptionOptions} options encryption options, see [[IEncryptionOptions]] for more details
     * @returns {string} return encrypted string with selected encoding
     */
    Encryptor.prototype.encrypt = function (data, options) {
        if (options === void 0) { options = this.options; }
        var key = options.key || this.options.key;
        if (key.length !== 32 || options.key === '') {
            throw new provider_1.InvalidKeyError('Key must be 32 characters');
        }
        var encryptionCount = options.encryptionCount || 1;
        var encoding = options.encoding || 'base64';
        var result = '';
        for (var i = 1; i <= encryptionCount; i++) {
            if (i === 1) {
                result = this.encryptor(data, key, encoding);
                continue;
            }
            result = this.encryptor(result, key, encoding);
        }
        if (options.writeToFile) {
            fs_1.default.writeFileSync(options.writeToFile, result);
        }
        return result;
    };
    /**
     * encrypt the given text with aes-256-cbc encryption algorithm
     * @param {string} pathToFile string of file path
     * @param {string} key (or secret) is 256bits (32 charcters) that used to encrypt dan decrypt the data, please store it in the safe places
     * @param {IEncryptionOptions} options encryption options, see [[IEncryptionOptions]] for more details
     * @returns {string} return encrypted string with selected encoding
     */
    Encryptor.prototype.encryptFile = function (pathToFile, options) {
        if (options === void 0) { options = this.options; }
        var key = options.key || this.options.key;
        if (key.length !== 32 || options.key === '') {
            throw new provider_1.InvalidKeyError('Key must be 32 characters');
        }
        var encryptionCount = options.encryptionCount || 1;
        var encoding = options.encoding || 'base64';
        // @ts-ignore
        var data = Buffer.from(fs_1.default.readFileSync(pathToFile), 'binary');
        var result = '';
        for (var i = 1; i <= encryptionCount; i++) {
            if (i === 1) {
                result = this.encryptor(data, key, encoding);
                continue;
            }
            result = this.encryptor(result, key, encoding);
        }
        if (options.writeToFile) {
            fs_1.default.writeFileSync(options.writeToFile, result);
        }
        return result;
    };
    /**
     * encrypt the given text with aes-256-cbc encryption algorithm
     * @param {string|Buffer} data string or buffer that will be encrypted
     * @param {string} key (or secret) is 256bits (32 charcters) that used to encrypt dan decrypt the data, please store it in the safe places
     * @param {Encoding} encoding string/text encoding you can choose `base64`(default) or `hex`
     * @returns {string} return encrypted string with selected encoding
     */
    Encryptor.prototype.encryptor = function (data, key, encoding) {
        if (encoding === void 0) { encoding = 'base64'; }
        /**
         * this expression will create a random Initialization Vector(IV)
         * for every encrypted data
         */
        var iv = crypto_1.default.randomBytes(config_1.IV_LENGTH);
        var cipher = crypto_1.default.createCipheriv(config_1.ALGORITHM, Buffer.from(key), iv);
        var encryptedData = cipher.update(data);
        encryptedData = Buffer.concat([encryptedData, cipher.final()]);
        /**
         * combine iv to returned encrypted data, and add the separator to distinguish the (IV)
         * data and the encrypted data,
         * and add separator to the end of data, this for decrypt purpose
         */
        if (encoding === 'base64') {
            return utils_1.removeBase64Padding(iv.toString(encoding)) + encryptedData.toString(encoding);
        }
        else {
            return iv.toString(encoding) + encryptedData.toString(encoding);
        }
        /**
         * the result of this function will be like this [IV][EncryptedData]
         */
    };
    return Encryptor;
}());
exports.Encryptor = Encryptor;
//# sourceMappingURL=encryptor.js.map